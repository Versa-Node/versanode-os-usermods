#!/usr/bin/env bash
set -Eeuo pipefail

OUT="/etc/nginx/conf.d/vncp-proxies.conf"
LABEL_KEY="io.versanode.vncp.proxies"
LISTEN_ADDR="80"
COCKPIT_PORT="9090"
NETWORK="<any>"
DRY_RUN=0
DEBUG=0
RELOAD_CMD="systemctl reload nginx"

log(){ echo "[vncp-nginx] $*"; }
dbg(){ [[ "$DEBUG" -eq 1 ]] && echo "[vncp-nginx][dbg] $*" >&2 || true; }
die(){ echo "[vncp-nginx][err] $*" >&2; exit 1; }

b64decode(){ printf "%s" "$1" | tr -d '\n' | base64 -d 2>/dev/null || true; }
get_upstream_host(){
  local cid="$1" netpref="$2"
  if [[ "${netpref}" == "<host>" ]]; then echo "127.0.0.1"; return; fi
  local mode; mode="$(docker inspect -f '{{.HostConfig.NetworkMode}}' "$cid" 2>/dev/null || true)"
  if [[ "${mode}" == "host" ]]; then echo "127.0.0.1"; return; fi
  if [[ "${netpref}" != "<any>" && -n "${netpref}" ]]; then
    docker inspect "$cid" | jq -r --arg n "$netpref" '.[0].NetworkSettings.Networks[$n].IPAddress // empty' | sed -n '1p'
  else
    docker inspect "$cid" | jq -r '.[0].NetworkSettings.Networks | to_entries[0].value.IPAddress // empty' | sed -n '1p'
  fi
}
subst_block(){
  local block="$1" slug="$2" path="$3" host="$4" port="$5"
  local upstream="http://${host}:${port}"
  esc(){ printf '%s' "$1" | sed -e 's/[\/&]/\\&/g'; }
  local e_path e_slug e_host e_port e_upstream
  e_path="$(esc "$path")"; e_slug="$(esc "$slug")"; e_host="$(esc "$host")"; e_port="$(esc "$port")"; e_upstream="$(esc "$upstream")"
  block="$(printf "%s" "$block" | sed \
    -e "s/\${PATH}/${e_path}/g" \
    -e "s/\${SLUG}/${e_slug}/g" \
    -e "s/\${UPSTREAM_IP}/${e_host}/g" \
    -e "s/\${UPSTREAM_PORT}/${e_port}/g" \
    -e "s|\${UPSTREAM}|${e_upstream}|g")"
  printf "%s" "$block" | sed -e 's/\$\$/$/g'
}
wrap_block_with_marker(){
  local slug="$1" cid="$2" host="$3" port="$4" body="$5"
  cat <<EOF
    # ---- proxy: /${slug}  (cid=${cid} upstream=${host}:${port}) ----
$(printf "%s\n" "$body")
EOF
}

# --- Discover labeled containers ---
entries_json="[]"
mapfile -t CIDS < <(docker ps -q --filter "label=${LABEL_KEY}")
for cid in "${CIDS[@]}"; do
  raw_label="$(docker inspect -f "{{ index .Config.Labels \"${LABEL_KEY}\" }}" "$cid" 2>/dev/null || true)"
  [[ -z "${raw_label}" || "${raw_label}" == "<no value>" ]] && continue
  normalized_array="$(
    printf '%s' "$raw_label" | jq -c '
      . as $raw
      | ((try (fromjson) catch $raw)) as $val
      | if ($val|type) == "array" then $val
        elif ($val|type) == "object" then
          [ $val | to_entries[] | { slug:(.key|tostring), v:.value }
            | (if (.v|type) == "object" then . + .v
               elif ((.v|type) == "string" or (.v|type) == "number") then . + { port:(.v|tostring) }
               else . end)
            | del(.v) ]
        else [] end
      | map({
          slug:(.slug?|tostring|ascii_downcase),
          port:(.port?//""|tostring),
          nginx_block_b64:(.nginx_block_b64?//""|tostring),
          nginx_block:(.nginx_block?//""|tostring)
        })
      | map(select(.slug != "" and .port != ""))
    '
  )"
  with_cid="$(jq --arg cid "$cid" 'map(. + { __cid: $cid })' <<<"$normalized_array")"
  entries_json="$(jq -s 'add' <(printf '%s' "$entries_json") <(printf '%s' "$with_cid"))"
done
count="$(jq 'length' <<<"$entries_json")"

# --- Generate full server block (always includes Cockpit) ---
tmpfile="$(mktemp)"; trap 'rm -f "$tmpfile"' EXIT
mkdir -p "$(dirname "$OUT")"

{
  cat <<EOF
# AUTOGENERATED â€” DO NOT EDIT.
# Requires nginx.conf to include /etc/nginx/conf.d/*.conf;
server {
    listen ${LISTEN_ADDR} default_server;
    server_name _;

    # Health
    location = /healthz { return 200; }

    # Root: 404
    location = / { return 404; }

    # Cockpit always available under /cockpit/
    location ^~ /cockpit/ {
        proxy_pass http://127.0.0.1:${COCKPIT_PORT}/cockpit/;
        proxy_http_version 1.1;
        proxy_buffering off;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;
        proxy_set_header Host \$host;
        proxy_set_header X-Forwarded-Proto http;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        gzip off;
    }

EOF

  if [[ "$count" -gt 0 ]]; then
    for i in $(seq 0 $((count-1))); do
      item="$(jq -r ".[$i]" <<<"$entries_json")"
      slug="$(jq -r '.slug' <<<"$item")"
      port="$(jq -r '.port' <<<"$item")"
      b64="$(jq -r '.nginx_block_b64 // ""' <<<"$item")"
      ptxt="$(jq -r '.nginx_block // ""' <<<"$item")"
      cid="$(jq -r '.__cid' <<<"$item")"
      host="$(get_upstream_host "$cid" "$NETWORK" || true)"
      [[ -z "$host" ]] && continue

      block_src=""
      if [[ -n "$b64" ]]; then block_src="$(b64decode "$b64")"
      elif [[ -n "$ptxt" ]]; then block_src="$ptxt"
      else continue; fi

      path="/${slug}"
      block_final="$(subst_block "$block_src" "$slug" "$path" "$host" "$port")"
      block_final_indented="$(printf "%s" "$block_final" | sed 's/^/    /')"
      wrap_block_with_marker "$slug" "$cid" "$host" "$port" "$block_final_indented"
    done
  fi

  cat <<'EOF'
    # Unknown paths -> 404
    location / { return 404; }
}
EOF
} >"$tmpfile"

# --- Write only if changed; reload only on change ---
need_write=1
if [[ -f "$OUT" ]] && cmp -s "$tmpfile" "$OUT"; then
  need_write=0
fi

if [[ "$need_write" -eq 1 ]]; then
  install -m 0644 -T "$tmpfile" "$OUT"
  if nginx -t >/dev/null 2>&1; then
    eval "${RELOAD_CMD}" || true
  fi
else
  log "No changes; not reloading nginx."
fi
