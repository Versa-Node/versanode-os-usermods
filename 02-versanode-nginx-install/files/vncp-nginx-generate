#!/usr/bin/env bash
set -Eeuo pipefail
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

# ── Outputs ──────────────────────────────────────────────────────────────────
OUT_HTTP="/etc/nginx/conf.d/vncp-proxies-80.conf"
OUT_HTTPS="/etc/nginx/conf.d/vncp-proxies-443.conf"
WS_MAP_FILE="/etc/nginx/conf.d/00-ws-upgrade-map.conf"
COCKPIT_CONF="/etc/cockpit/cockpit.conf"

# ── Settings ────────────────────────────────────────────────────────────────
LABEL_KEY="io.versanode.vncp.proxies"

: "${LISTEN_ADDR_HTTP:=80}"
: "${LISTEN_ADDR_HTTPS:=443}"
: "${COCKPIT_PORT:=9090}"
: "${NETWORK:=<any>}"
: "${RELOAD_CMD:=systemctl reload nginx}"

# TLS + mkcert
: "${TLS_ENABLE:=1}"
: "${TLS_DIR:=/etc/nginx/tls}"
: "${CA_DIR:=${TLS_DIR}/ca}"
: "${SRV_DIR:=${TLS_DIR}/server}"
: "${COCKPIT_WS_DIR:=/etc/cockpit/ws-certs.d}"
: "${LOCAL_HOSTNAME:=versanode.local}"           # primary local hostname for mkcert
: "${EXTRA_SANS:=}"                               # comma-separated extra SANs, e.g. "DNS:foo.local,IP:10.0.0.5"

CA_KEY="${CA_DIR}/ca.key"
CA_CRT="${CA_DIR}/ca.crt"
SRV_KEY="${SRV_DIR}/server.key"
SRV_CRT="${SRV_DIR}/server.crt"
SRV_CSR="${SRV_DIR}/server.csr"

COCKPIT_CERT="${COCKPIT_WS_DIR}/10-${LOCAL_HOSTNAME}.cert"
COCKPIT_KEY="${COCKPIT_WS_DIR}/10-${LOCAL_HOSTNAME}.key"

: "${TLS_CIPHERS:=HIGH:!aNULL:!MD5}"
: "${TLS_PROTOCOLS:=TLSv1.2 TLSv1.3}"
: "${SRV_DAYS:=825}"
: "${RENEW_DAYS:=10}"

: "${STATE_DIR:=/var/lib/vncp-nginx}"
LAST_HOST_FILE="${STATE_DIR}/last_hostname"

log(){ echo "[vncp-nginx] $*"; }
die(){ echo "[vncp-nginx][err] $*" >&2; exit 1; }
b64decode(){ printf "%s" "$1" | tr -d "\n" | base64 -d 2>/dev/null || true; }

write_if_changed(){ # src dst -> 0 wrote/changed, 1 identical
  local src="$1" dst="$2"
  if [[ -f "$dst" ]] && cmp -s "$src" "$dst"; then return 1; fi
  install -D -m 0644 -T "$src" "$dst"
  return 0
}

# ── Docker helpers (optional labels → upstream discovery) ───────────────────
get_upstream_host(){
  local cid="$1" netpref="$2"
  if [[ "${netpref}" == "<host>" ]]; then echo "127.0.0.1"; return; fi
  local mode; mode="$(docker inspect -f "{{.HostConfig.NetworkMode}}" "$cid" 2>/dev/null || true)"
  if [[ "${mode}" == "host" ]]; then echo "127.0.0.1"; return; fi
  if [[ "${netpref}" != "<any>" && -n "${netpref}" ]]; then
    docker inspect "$cid" | jq -r --arg n "$netpref" '.[0].NetworkSettings.Networks[$n].IPAddress // empty' | sed -n '1p'
  else
    docker inspect "$cid" | jq -r '.[0].NetworkSettings.Networks | to_entries[0].value.IPAddress // empty' | sed -n '1p'
  fi
}

subst_block(){
  local block="$1" slug="$2" path="$3" host="$4" port="$5"
  local upstream="http://${host}:${port}"
  esc(){ printf '%s' "$1" | sed -e 's/[\/&]/\\&/g'; }
  local e_path e_slug e_host e_port e_upstream
  e_path="$(esc "$path")"; e_slug="$(esc "$slug")"; e_host="$(esc "$host")"; e_port="$(esc "$port")"; e_upstream="$(esc "$upstream")"
  block="$(printf "%s" "$block" | sed \
    -e "s/\${PATH}/${e_path}/g" \
    -e "s/\${SLUG}/${e_slug}/g" \
    -e "s/\${UPSTREAM_IP}/${e_host}/g" \
    -e "s/\${UPSTREAM_PORT}/${e_port}/g" \
    -e "s|\${UPSTREAM}|${e_upstream}|g")"
  printf "%s" "$block" | sed -e 's/\$\$/$/g'
}

collect_sans(){
  local sans=()
  # primary .local name first
  [[ -n "$LOCAL_HOSTNAME" ]] && sans+=("DNS:${LOCAL_HOSTNAME}")

  # system hostnames
  local fqdn sh
  fqdn="$(hostname -f 2>/dev/null || true)"; sh="$(hostname -s 2>/dev/null || true)"
  [[ -n "$fqdn" ]] && sans+=("DNS:${fqdn}")
  [[ -n "$sh" && "$sh" != "$fqdn" ]] && sans+=("DNS:${sh}")

  # IPs
  while read -r ip; do [[ -n "$ip" ]] && sans+=("IP:${ip}"); done < <(ip -o -4 addr show | awk '{print $4}' | cut -d/ -f1)
  while read -r ip6; do [[ -n "$ip6" ]] && sans+=("IP:${ip6}"); done < <(ip -o -6 addr show scope global | awk '{print $4}' | cut -d/ -f1)

  # extra SANs (comma-separated: DNS:foo,IP:1.2.3.4)
  if [[ -n "$EXTRA_SANS" ]]; then
    IFS=, read -ra E <<<"$EXTRA_SANS"; for e in "${E[@]}"; do [[ -n "$e" ]] && sans+=("$e"); done
  fi
  (IFS=,; printf "%s" "${sans[*]}")
}

# ── Ensure $connection_upgrade map exists ───────────────────────────────────
ensure_ws_map(){
  if ! grep -qs 'map $http_upgrade $connection_upgrade' "$WS_MAP_FILE" 2>/dev/null; then
    install -D -m 0644 /dev/stdin "$WS_MAP_FILE" <<'CONF'
# AUTOGENERATED — websocket upgrade map for $connection_upgrade
map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}
CONF
    return 0
  fi
  return 1
}

# ── Cockpit: force UrlRoot=/cockpit so assets/cookies align ─────────────────
ensure_cockpit_conf(){
  local tmp; tmp="$(mktemp)"
  mkdir -p "$(dirname "$COCKPIT_CONF")"
  cat >"$tmp" <<'EOF'
[WebService]
UrlRoot=/cockpit
# Allow all origins while testing behind reverse proxy; restrict later.
Origins=*
EOF
  if write_if_changed "$tmp" "$COCKPIT_CONF"; then rm -f "$tmp"; return 0; fi
  rm -f "$tmp"; return 1
}

# ── TLS via mkcert first; fallback to OpenSSL local CA ──────────────────────
ensure_tls(){
  [[ "$TLS_ENABLE" -eq 1 ]] || return 0
  mkdir -p "$CA_DIR" "$SRV_DIR" "$STATE_DIR" "$COCKPIT_WS_DIR"

  local current_host; current_host="$(hostname -f 2>/dev/null || hostname 2>/dev/null || echo localhost)"
  local last_host=""; [[ -s "$LAST_HOST_FILE" ]] && last_host="$(cat "$LAST_HOST_FILE" 2>/dev/null || true)" || true

  if [[ "$current_host" != "$last_host" ]]; then
    echo "$current_host" > "$LAST_HOST_FILE"
    rm -f "$SRV_KEY" "$SRV_CRT" "$SRV_CSR" || true
    log "Hostname changed (${last_host} -> ${current_host}); certs will be (re)issued."
  fi

  local used_mkcert=0
  if command -v mkcert >/dev/null 2>&1; then
    used_mkcert=1
    log "mkcert found — generating a locally-trusted certificate for ${LOCAL_HOSTNAME}"
    # Build mkcert SAN args: mkcert takes bare names/IPs
    # We pass: LOCAL_HOSTNAME, hostnames, and IPs
    mapfile -t SAN_LIST < <(
      {
        [[ -n "$LOCAL_HOSTNAME" ]] && echo "$LOCAL_HOSTNAME"
        hostname -f 2>/dev/null || true
        hostname -s 2>/dev/null || true
        ip -o -4 addr show | awk '{print $4}' | cut -d/ -f1
        ip -o -6 addr show scope global | awk '{print $4}' | cut -d/ -f1
      } | awk 'NF' | sort -u
    )
    # mkcert writes both files directly; we set filenames to our target
    mkcert -cert-file "$SRV_CRT" -key-file "$SRV_KEY" "${SAN_LIST[@]}" >/dev/null 2>&1 || {
      log "mkcert failed; falling back to OpenSSL local CA."
      used_mkcert=0
      rm -f "$SRV_CRT" "$SRV_KEY" || true
    }
  fi

  if [[ "$used_mkcert" -eq 0 ]]; then
    # OpenSSL local CA fallback (clients must install $CA_CRT to trust)
    [[ -s "$CA_KEY" && -s "$CA_CRT" ]] || {
      log "Creating local OpenSSL CA (once) in $CA_DIR"
      openssl genrsa -out "$CA_KEY" 4096 >/dev/null 2>&1
      openssl req -x509 -new -nodes -key "$CA_KEY" -sha256 -days 3650 \
        -subj "/CN=VersaNode Local CA" -out "$CA_CRT" >/dev/null 2>&1
      log "Local CA created: ${CA_CRT}  (distribute to client trust stores)"
    }

    local recreate=0
    if [[ -s "$SRV_CRT" ]]; then
      local enddate expiry_ts now_ts days_left
      enddate="$(openssl x509 -enddate -noout -in "$SRV_CRT" 2>/dev/null | cut -d= -f2 || true)"
      if [[ -n "$enddate" ]]; then
        expiry_ts="$(date -d "$enddate" +%s 2>/dev/null || true)"
        now_ts="$(date +%s)"
        if [[ -n "$expiry_ts" ]]; then
          days_left="$(( (expiry_ts - now_ts) / 86400 ))"
          (( days_left < RENEW_DAYS )) && recreate=1
        fi
      fi
    else
      recreate=1
    fi

    if (( recreate )); then
      local SANS; SANS="$(collect_sans)"
      log "Issuing server certificate via local CA (SANs: $SANS, days: ${SRV_DAYS})"
      cat >"$SRV_DIR/openssl.cnf" <<CFG
[req]
distinguished_name=req
req_extensions=req_ext
prompt=no
[req_ext]
subjectAltName=${SANS}
CFG
      openssl genrsa -out "$SRV_KEY" 2048 >/dev/null 2>&1
      openssl req -new -key "$SRV_KEY" -subj "/CN=${LOCAL_HOSTNAME}" \
        -out "$SRV_CSR" -config "$SRV_DIR/openssl.cnf" >/dev/null 2>&1
      openssl x509 -req -in "$SRV_CSR" -CA "$CA_CRT" -CAkey "$CA_KEY" -CAcreateserial \
        -out "$SRV_CRT" -days "$SRV_DAYS" -sha256 -extfile "$SRV_DIR/openssl.cnf" -extensions req_ext >/dev/null 2>&1
      log "Server cert created: ${SRV_CRT} (trust CA on clients: ${CA_CRT})"
    fi
  else
    # mkcert path: advise user about client-side CA install
    log "mkcert certificate ready at ${SRV_CRT}. Ensure mkcert CA is installed on client machines."
  fi

  # perms for Nginx & Cockpit
  chown root:root "$SRV_KEY" "$SRV_CRT" || true
  chmod 0640 "$SRV_KEY" || true
  chmod 0644 "$SRV_CRT" || true

  # Cockpit wants cert+key; support separate files as requested
  # Copy/symlink to ws-certs.d so Cockpit picks it up
  install -d -m 0755 "$COCKPIT_WS_DIR"
  # Use copies to avoid surprises if TLS_DIR is on a different FS
  install -m 0644 "$SRV_CRT" "$COCKPIT_CERT"
  install -m 0640 "$SRV_KEY" "$COCKPIT_KEY"
}

# ── Optional: discover container proxies via labels ─────────────────────────
docker_not_found=0
if ! command -v docker >/dev/null 2>&1; then
  docker_not_found=1
  log "Docker not found; skipping container proxy labels (ok)."
fi

entries_json="[]"
if [[ "$docker_not_found" -eq 0 ]]; then
  mapfile -t CIDS < <(docker ps -q --filter "label=${LABEL_KEY}") || true
  for cid in "${CIDS[@]:-}"; do
    raw_label="$(docker inspect -f "{{ index .Config.Labels \"${LABEL_KEY}\" }}" "$cid" 2>/dev/null || true)"
    [[ -z "${raw_label}" || "${raw_label}" == "<no value>" ]] && continue
    normalized_array="$(
      printf '%s' "$raw_label" | jq -c '
        . as $raw
        | ((try (fromjson) catch $raw)) as $val
        | if ($val|type) == "array" then $val
          elif ($val|type) == "object" then
            [ $val | to_entries[] | { slug:(.key|tostring), v:.value }
              | (if (.v|type) == "object" then . + .v
                 elif ((.v|type) == "string" or (.v|type) == "number") then . + { port:(.v|tostring) }
                 else . end)
              | del(.v) ]
          else [] end
        | map({ slug:(.slug?|tostring|ascii_downcase), port:(.port?//""|tostring), nginx_block_b64:(.nginx_block_b64?//""|tostring), nginx_block:(.nginx_block?//""|tostring) })
        | map(select(.slug != "" and .port != ""))'
    )"
    with_cid="$(jq --arg cid "$cid" 'map(. + { __cid: $cid })' <<<"$normalized_array")"
    entries_json="$(jq -s 'add' <(printf '%s' "$entries_json") <(printf '%s' "$with_cid"))"
  done
fi
count="$(jq 'length' <<<"$entries_json")"

# ── Ensure TLS + ws map + cockpit.conf ──────────────────────────────────────
ensure_tls
ws_changed=0; ensure_ws_map && ws_changed=1
cockpit_changed=0; ensure_cockpit_conf && cockpit_changed=1

# ── Generate nginx servers ──────────────────────────────────────────────────
tmp80="$(mktemp)"; tmp443="$(mktemp)"; trap 'rm -f "$tmp80" "$tmp443"' EXIT
mkdir -p "$(dirname "$OUT_HTTP")" "$(dirname "$OUT_HTTPS")"

cat >"$tmp80" <<EOF
# AUTOGENERATED — DO NOT EDIT.
server {
    listen ${LISTEN_ADDR_HTTP} default_server;
    server_name _;
    location = /healthz { return 200; }
    location / { return 308 https://\$host\$request_uri; }
}
EOF

cat >"$tmp443" <<EOF
# AUTOGENERATED — DO NOT EDIT.
server {
    listen ${LISTEN_ADDR_HTTPS} ssl default_server;
    http2 on;
    server_name _;
    ssl_certificate     ${SRV_CRT};
    ssl_certificate_key ${SRV_KEY};
    ssl_session_timeout 1d;
    ssl_session_cache shared:MozSSL:10m;
    ssl_session_tickets off;
    ssl_protocols ${TLS_PROTOCOLS};
    ssl_ciphers   ${TLS_CIPHERS};
    ssl_prefer_server_ciphers on;

    location = /healthz { return 200; }
    location = /          { return 308 /cockpit/; }
    location = /cockpit   { return 308 /cockpit/; }

    # Cockpit under /cockpit/, passed through unchanged (NO trailing slash)
    location ^~ /cockpit/ {
        proxy_pass http://127.0.0.1:${COCKPIT_PORT};
        proxy_http_version 1.1;
        proxy_buffering off;

        # WebSocket/HTTP upgrade
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;
        # Mirror browser origin for WS/CSRF sanity
        proxy_set_header Origin \$scheme://\$host;

        # Forwarded headers
        proxy_set_header Host \$host;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header X-Forwarded-Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;

        # Helpful timeouts for WS
        proxy_read_timeout  1h;
        proxy_send_timeout  1h;

        proxy_redirect off;
        gzip off;
    }

EOF

if [[ "$count" -gt 0 ]]; then
  for i in $(seq 0 $((count-1))); do
    item="$(jq -r ".[$i]" <<<"$entries_json")"
    slug="$(jq -r '.slug' <<<"$item")"
    port="$(jq -r '.port' <<<"$item")"
    b64="$(jq -r '.nginx_block_b64 // ""' <<<"$item")"
    ptxt="$(jq -r '.nginx_block // ""' <<<"$item")"
    cid="$(jq -r '.__cid' <<<"$item")"
    host="$(get_upstream_host "$cid" "$NETWORK" || true)"
    [[ -z "$host" ]] && continue
    block_src=""; if [[ -n "$b64" ]]; then block_src="$(b64decode "$b64")"; elif [[ -n "$ptxt" ]]; then block_src="$ptxt"; else continue; fi
    path="/${slug}"
    block_final="$(subst_block "$block_src" "$slug" "$path" "$host" "$port")"
    printf "    # ---- proxy: /%s  (cid=%s upstream=%s:%s) ----\n" "$slug" "$cid" "$host" "$port" >>"$tmp443"
    printf "%s\n\n" "$(printf "%s" "$block_final" | sed "s/^/    /")" >>"$tmp443"
  done
fi

cat >>"$tmp443" <<'EOF'
    location / { return 404; }
}
EOF

# ── Write files and reload daemons when changed ─────────────────────────────
changed=0
write_if_changed "$tmp80"  "$OUT_HTTP"  && changed=1
write_if_changed "$tmp443" "$OUT_HTTPS" && changed=1

# Drop Debian's default site to avoid conflicts
if [ -e /etc/nginx/sites-enabled/default ]; then
  rm -f /etc/nginx/sites-enabled/default || true
  changed=1
fi

# If cockpit.conf changed, restart the socket & stop any running instance
if [[ "$cockpit_changed" -eq 1 ]]; then
  log "cockpit.conf changed; restarting cockpit.socket"
  systemctl restart cockpit.socket || true
  systemctl stop cockpit || true   # it respawns on next request
fi

# Test & reload nginx when something changed
if [[ "$changed" -eq 1 || "$ws_changed" -eq 1 ]]; then
  if nginx -t >/dev/null 2>&1; then
    $RELOAD_CMD || true
    log "Nginx reloaded (TLS + redirects + ws map + cockpit @ /cockpit)."
  else
    die "nginx -t failed"
  fi
else
  log "No nginx changes; not reloading."
fi

log "Done. Try: https://${LOCAL_HOSTNAME}/cockpit/  (or https://$(hostname -f 2>/dev/null || hostname)/cockpit/)"
log "Note: For a green lock, client machines must trust the mkcert CA (mkcert -install on each client) or import ${CA_CRT} if OpenSSL fallback was used."
